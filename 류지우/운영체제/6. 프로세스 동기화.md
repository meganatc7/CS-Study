## [프로세스 동기화 #1]
### 데이터의 접근

- Data / 연산할 data / 연산 / 연산 결과

### Race Condition

- Storage-Box(Memory Address Space)를 공유하는 Execution-Box(CPU Process)가 여럿 있는 경우 Race Condition의 가능성

### OS에서의 Race Condition

- 커널모드 running 중 interrupt가 발생하여 인터럽트 처리루틴이 수행
  - 양쪽 다 커널 코드이므로 kernel address space 공유

- 두 프로세스의 address space간에는 data sharing이 없음
  - system call을 하는 동안에는 kernel address space의 data를 access하게 됨
  - 이 작업 중간에 CPU를 preempt 해가면 race condition 발생 
  - 해결 : 커널 모드에서 수행중일 때는 CPU를 preempt하지 않음, 커널 모드에서 사용자 모드로 돌아갈 때 preempt
- 어떤 CPU가 마지막으로 count를 store했는가?
  - 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법
  - 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 하는 방법

### Process Synchronization 문제

- 공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있다
- 일관성 유지를 위해서는 협력 프로세스간의 실행 순서를 정해주는 메커니즘 필요

- Example of a Race Condition
  - 여러 프로스세들이 동시에 공유 데이터를 접근하는 상황
  - 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
- The Critical-Section Problem

### 프로그램적 해결법의 충족조건

- Initial Attempts to Solve Problem

## [프로세스 동기화 #2]

### Semaphores

- integer variable
- 두 가지 atomic 연산에 의해서만 접근 가능

### Critical Section of n Processes

- critical section : 공유 데이터를 접근하는 코드
- busy-wait는 효율적이지 못함(=spin lock)
- Block & Wakeup 방식의 구현(=sleep lock)

### Block / Wakeup Implementation

- block 
  - 커널은 block을 호출한 프로세스를 suspend시킴
  - 이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣음
- wakeup
  - block된 프로세스 P를 wakeup 시킴
  - 이 프로세스의 PCB를 ready queue로 옮김

- P(S)

  ```
  s.value--;
  if(S.value<0)
  {
    add this process to S.L;
    block();
  }
  ```

- V(S)

  ```
  s.value++;
  if(S.value<0)
  {
    remove a process P from S.L;
    wakeup(P);
  }
  ```

### Two Types of Semaphores

- Counting semaphore
  - 도메인이 0 이상인 임의의 정수값
  - 주로 resource counting에 사용
- Binary semaphore(=mutex)
  - 0 또는 1 값만 가질 수 있는 semaphore
  - 주로 mutual exclusion (lock/unlock)에 사용

### Deadlock and Starvation

- Deadlock
  - 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상
- Starvation
  - indefinite blocking. 프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상
