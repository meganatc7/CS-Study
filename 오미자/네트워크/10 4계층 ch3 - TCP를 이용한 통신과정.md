# ☔10 4계층 ch3 - TCP를 이용한 통신과정

TCP를 이용한 데이터 통신을 할 때, 단순히 TCP 패킷 만을 캡슐화해서 통신하는 것이 아니라 페이로드를 포함한 패킷을 주고 받을 때의 일정한 **규칙**이 있다.

- 보낸 쪽에서 또 보낼 때는 Seq번호와 Ack 번호가 그대로이다.
- 받는 쪽에서 Seq번호는 받은 Ack번호가 된다. **(Seq == Ack)**
- 받는 쪽에서 Ack번호는 Seq 번호 + 데이터 크기가 된다. **(Ack == Seq + data)**





### 통신과정

- 클라이언트가 서버에게 어떤 데이터에 대한 요청을 보낸다. (보내는 데이터 크기 100)

  <img src="img/TCP%20%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/1.png" alt="1" style="zoom: 67%;" />

  <img src="img/TCP%20%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/2.png" alt="2" style="zoom:67%;" />

- 서버는 데이터를 잘 받았다는 표시를 위해 Ack번호가 이전 패킷의 Seq번호에 받은 데이터 크기(100)을 더한 상태로 보낸다. (101 + 100 == 201 == **Ack**) **(전 패킷의 Seq + Data == 현 패킷의 Ack)**

  보낼 때 Seq값은 받은 패킷의 Ack번호와 같다. **(전 패킷의 ACK == 현 패킷의 Seq)**

  ![3](img/TCP%20%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/3.png)

  

- 클라이언트는 데이터를 잘 받았다는 의미로 다시 패킷을 보내는데, 여기서 Seq는 받았던 패킷의 Ack 즉 201이 되고 Ack는 받았던 Seq + 데이터크기 == 2501의 값으로 보내진다.

  ![4](img/TCP%20%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/4.png)

  



## 🌂TCP 상태 전이도

- `LISTEN`

  포트번호를 열어놓고 있는 상태(서버쪽에서 포트를 사용하고 있는 상태)

  요청이 들어오면 바로 들을 수 있음

  -> 서버를 실행시켰을 때 LISTEN 상태인지 확인해봐야 한다.

- `ESTABLISHED`

  연결이 수립이 된 상태



1. 서버는 항상 `LISTEN` 상태여야 한다.

   ![TCP상태 1](img/TCP%20%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/TCP%EC%83%81%ED%83%9C%201.png)

2. 클라이언트가 패킷을 만들어서 보내면, 클라이언트는 SYN_SENT 상태가 되고, 서버가 패킷을 받으면 `SYN_RECEIVED` 상태가 된다.

   ![TCP상태 2](img/TCP%20%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/TCP%EC%83%81%ED%83%9C%202.png)

3. 클라이언트가 패킷을 받은 후 ACK 패킷을 보내게 되면 클라이언트는 `ESTABLISHED`상태가 되고, 서버측에서도 패킷을 받으면 `ESTABLISHED` 상태가 되며, 이제 데이터를 주고 받을 수 있는 상태가 된다.

   ![TCP상태 5](img/TCP%20%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0/TCP%EC%83%81%ED%83%9C%205.png)

