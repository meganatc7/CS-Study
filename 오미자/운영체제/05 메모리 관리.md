# 🌲 메모리 관리

## 🍒 메모리 종류

메모리의 종류로는 크게 레지스터, 캐시, 메인메모리, 보조기억장치가 있다.

레지스터 > 캐시 > 메인메모리 > 보조기억장치 순으로 속도가 빠르며 가격 또한 비싸다.

레지스터와 캐시는 HW(CPU) 에서 관리하고, 메인메모리와 보조기억장치는 SW(OS)에서 관리된다.

![메모리종류](img/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A2%85%EB%A5%98.png)

### 계층구조

![메모리 계층구조](img/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0.PNG)

Block

- 보조기억장치와 주기억장치 사이의 데이터 전송 단위(1~4KB)
- 보조기억장치에서 1bit만 읽는다고 해도 주기억장치에는 block단위로 올라온다.

Word

- 주기억장치와 레지스터 사이의 데이터 전송단위(16~64bit)
- 32bit, 64bit 컴퓨터 할 때 기준이 되는 것





### 🍒 Address Binding

프로그램 논리 주소를 실제 메모리의 물리 주소로 매핑하는 작업

> int a; <-> 메모리 상 주소



![스텝](img/%EC%8A%A4%ED%85%9D.PNG)

먼저 위의 과정은 어떤 프로그램을 구현했을 때, 메모리에 올라가 실행되기 까지의 과정이다.



- **Compile time binding**
  - **컴파일러가 직접 주소를 정해주는 것** -> 프로세스가 메모리에 적재될 위치를 컴파일러가 아는 경우만 가능하며 위치가 변하지 않는다는 한계가 있다.
- **Load time binding**
  - **대체 가능한 상대 주소를 생성** -> 적재 시험(load time)에 시작주소를 반영하여 사용자 코드 상의 주소를 재설정한다.
- **Run time binding**
  - **실제로 수행될 때 메모리에 올라감** (ready => running)
  - HW의 도움이 필요하다.(MMU)
  - 대부분의 OS가 사용중



### 🍒 Dynamic Loading

모든 루틴(ex: func)을 교체 가능한 형태로 디스크에 저장한다.

실제로 호출 전까지는 루틴을 적재하지 않고, 호출 시점에 address binding 수행된다.

**메모리 공간을 효율적으로 사용할 수 있다.**



### Swapping

프로세서 할당이 끝나고 수행 완료 된 프로세스는 swap-device로 보내고 (swap-out)

새롭게 시작하는 프로세스는 메모리에 적재한다.(swap-in)