# 🌲 메모리 관리

## 🍒 메모리 종류

메모리의 종류로는 크게 레지스터, 캐시, 메인메모리, 보조기억장치가 있다.

레지스터 > 캐시 > 메인메모리 > 보조기억장치 순으로 속도가 빠르며 가격 또한 비싸다.

레지스터와 캐시는 HW(CPU) 에서 관리하고, 메인메모리와 보조기억장치는 SW(OS)에서 관리된다.

![메모리종류](img/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A2%85%EB%A5%98.png)

### 계층구조

![메모리 계층구조](img/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0.PNG)

Block

- 보조기억장치와 주기억장치 사이의 데이터 전송 단위(1~4KB)
- 보조기억장치에서 1bit만 읽는다고 해도 주기억장치에는 block단위로 올라온다.

Word

- 주기억장치와 레지스터 사이의 데이터 전송단위(16~64bit)
- 32bit, 64bit 컴퓨터 할 때 기준이 되는 것





### 🍒 Address Binding

프로그램 논리 주소를 실제 메모리의 물리 주소로 매핑하는 작업

> int a; <-> 메모리 상 주소



![스텝](img/%EC%8A%A4%ED%85%9D.PNG)

먼저 위의 과정은 어떤 프로그램을 구현했을 때, 메모리에 올라가 실행되기 까지의 과정이다.



- **Compile time binding**
  - **컴파일러가 직접 주소를 정해주는 것** -> 프로세스가 메모리에 적재될 위치를 컴파일러가 아는 경우만 가능하며 위치가 변하지 않는다는 한계가 있다.
- **Load time binding**
  - **대체 가능한 상대 주소를 생성** -> 적재 시험(load time)에 시작주소를 반영하여 사용자 코드 상의 주소를 재설정한다.
- **Run time binding**
  - **실제로 수행될 때 메모리에 올라감** (ready => running)
  - HW의 도움이 필요하다.(MMU)
  - 대부분의 OS가 사용중



### 🍒 Dynamic Loading

모든 루틴(ex: func)을 교체 가능한 형태로 디스크에 저장한다.

실제로 호출 전까지는 루틴을 적재하지 않고, 호출 시점에 address binding 수행된다.

**메모리 공간을 효율적으로 사용할 수 있다.**



### Swapping

프로세서 할당이 끝나고 수행 완료 된 프로세스는 swap-device로 보내고 (swap-out)

새롭게 시작하는 프로세스는 메모리에 적재한다.(swap-in)





## Continuous Memory Allocation

프로세스를 하나의 연속된 메모리 공간에 할당하는 정책



#### (1) Uni-programming

Multiprogramming degree = 1

- 프로세스가 한번에 1개만 올라가는 경우

- 가장 간단한 메모리 관리 기법으로 하나의 프로세스만 메모리 상에 존재하게 된다.



**문제점**

- 프로그램의 크기가 메모리 크기보다 클 경우 문제가 발생한다.

  - **Overlay structure**

    공통된 부분만 올려놓고 공통되지 않은 부분은 프로그래머가 따로 분리해서 올려놓아야 한다.	

    -> 메모리에 필요한 영역만 적재한다.

    -> 사용자가 프로그램의 흐름 및 자료구조를 모두 알고 있어야 한다.

- 커널을 침범하게 될 경우 문제가 발생한다.

  - 경계 레지스터(boundary register)를 사용한다.

    ![유니프로그래밍](img/%EC%9C%A0%EB%8B%88%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png)

    커널 ADDRESS를 놓아서 그 밑에 할당되도록 한다

    -> 밑에 공간이 낭비될 수 있다. 

    -> Multi-programming이 필요하다.







### (2) Multi-programming

**(2-1) Fixed Partition**

- 메모리 공간을 고정된 크기로 분할해놓는다. -> 메모리 관리가 간편하다.
- 각 프로세스를 하나의 partition에 적재한다.
- partition의 수 = Multiprogramming degree

- 경계마다 `Boundary address`를 놓아서 프로세스가 `partition`에 잘 들어가도록 한다.

![멀티프로그래밍-1](img/%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1.png)

- **문제점: 내부 단편화 / 외부 단편화**

​	![단편화](img/%EB%8B%A8%ED%8E%B8%ED%99%94.png)

​	**내부 단편화**(Internal fragmentation) : Partition 크기 > Process 크기 -> **메모리 낭비**

​	**외부 단편화**(External fragmentation) : 남은 메모리 크기 > Process 크기 이지만 연속된 공간이 아니다. -> **메모리 낭비**