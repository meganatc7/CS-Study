# 20 스레드 관리

### [20.1] 프로세스와 스레드

#### [20.1.1] 프로세스의 역할

![20.1 프로세스](img/20.1%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.PNG)

자원(코드, 전역데이터, 힙 등)을 할당받고, 자원을 제어하여 원하는 목표를 달성하는 것이 프로세스의 역할이다.

이 때, 제어부분만 따로 수행하는 것이 바로 **스레드** 이다.

이 스레드는 여러개 있을 수 있다.



### [20.2] 스레드

![20.1 스레드](img/20.1%20%EC%8A%A4%EB%A0%88%EB%93%9C.PNG)

**자원은 공유하며**, 제어하는 것은 여러개이다.

- LWP(Light Weight Process)
- 프로세서 활용의 기본 단위이다.
- **Thread ID, Register set(PC, SP 등), Stack(==local date)** 으로 구성돼있다.

- 전통적 프로세스 == 단일 스레드 프로세스라고 생각하면 된다.



### [20.3] 스레드 장점

1. 사용자 응답성: 일부 스레드의 처리가 지연되어도, 다른 스레드는 작업을 계속 처리할 수 있다.
2. 자원 공유: 자원을 공유하기 때문에 효율성이 증가된다. (커널의 개입을 피할 수 있다 => context switch가 발생하지 않는다.)
3. 경제성: 프로세스의 생성, context switch에 비해 효율적이다.
4. 멀티 프로세서 활용: 병렬처리를 통해 성능이 향상된다.



### [20.4] 스레드 구현

#### [20.4.1] 사용자 수준 스레드

![20.4 사용자 수준 스레드](img/20.4%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%A4%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.PNG)

- 사용자 영역의 스레드 라이브러리로 구현된다.
  - 스레드 생성, 스케쥴링 등
  - POSIX threads, Win32 threads, Java thread API 등
- 커널은 스레드의 존재를 모른다.
  - 장점: 커널의 개입을 받지 않는다. => 생성 및 관리의 부하가 적어 유연한 관리 가능, 이식성이 높다, 이식성이 높다(라이브러리만 있으면 어디에서든 사용할 수 있다.)
  - 단점: 커널은 프로세스 단위로 자원을 할당하게 되는데, 만약 하나의 스레드가 block상태가 되면 커널 스레드와 1대1 매핑이기 때문에 같이 block상태가 된다. 따라서 모든 스레드가 대기상태가 된다.



#### [20.4.2] 커널 수준 스레드

![20.4.1 커널수준 스레드](img/20.4.1%20%EC%BB%A4%EB%84%90%EC%88%98%EC%A4%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.PNG)

- OS(커널)가 직접 관리한다.
- 장점: 커널이 각 스레드를 개별적으로 관리하기 때문에 프로세스 내 스레드들이 병행 수행 가능하다.
- 단점: 커널 영역에서 스레드의 생성, 관리를 수행하게 되기 때문에 프로세스 만큼은 아니지만 context switching 등 부하(오버헤드)가 크다.



#### [20.4.3] 혼합형 스레드

![20.4 혼합형 스레드](img/20.4%20%ED%98%BC%ED%95%A9%ED%98%95%20%EC%8A%A4%EB%A0%88%EB%93%9C.PNG)

n개 사용자 수준 스레드 - m개 커널 스레드

- 사용자는 원하는 수만큼 스레드 사용한다.
- 커널 스레드는 자신에게 할당된 사용자 스레드가 block 상태가 되어도, 다른 스레드 수행이 가능하다. => 병렬 처리 가능

