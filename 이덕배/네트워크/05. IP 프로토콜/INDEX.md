# INDEX

[toc]

## IPv4

>  멀리있는 곳과의 통신, IP는 3계층 프로토콜

### IPv4가 하는 일

- (다른) 네트워크 상에서 데이터를 교환하기 위한 프로토콜
- ==**데이터가 정확하게 전달될 것을 보장 ❌**==
- 중복된 패킷을 전달하거나 패킷의 순서를 잘못 전달할 가능성 있음
- 데이터의 정확하고 순차적인 전달을 그보다 상위 프로토콜인 TCP(4계층)에서 보장

### IPv4 프로토콜의 구조

![image-20211014222455443](assets/image-20211014222455443.png)

- 한 줄 == 4바이트
- 마지막 줄(IP Option)은 붙을 수도, 안붙을 수도 있는 옵션적인 요소 == > 제외하고 20바이트
  - 최대 열개의 옵션이 붙을 수 있지만(60바이트), 거의 이렇게 사용 X

<hr>

- **Source Address** : 출발지 주소(4바이트)

- **Destination Address** : 목적지 주소(4바이트)

- **Version | IHL | Type of Service | Total Length** 

  - Version : 버전(4만 온다. IPv6는 아예 구조가 다름)
  - IHL : 헤더의 길이(최소 20바이트, 최대 60바이트 '**/4**'를 하여 표시==> 4비트로 표현) 일반적으로 5가 된다.
  - Type of Service : 0 0으로 비워둔다. 옛날에 데이터의 중요성 등을 표시하는 정보
  - Total Length : 뒤의 페이로드까지 합쳐진 길이(상위 계층에서 인캡슐레이션하며 내려온 데이터와 합쳐진 전체의 길이)

- **Idenfication | Flag | Fragment Offset** : 하나의 세트(데이터를 보낼 때 최대 전송 단위가 있기에 잘게잘게 잘라서 보내는데, 그때 사용되는 것으로 쪼개진 정보 식별에 사용됨)

  - Idenfication : 쪼개진 데이터를 합쳐야 할 때, 쪼개진 네트워크들이 하나였다는 것을 알 수 있게 아이디를 같게 주는 것

    <img src="assets/image-20211014223841760.png" alt="image-20211014223841760" style="zoom:80%;" />

  - Flag : 3비트로 구성(x: 사용 안함 / D(don't fragmentation) : 데이터를 안쪼개서 보내겠다고 명시(다만 용량으로 인해 전송이 안됨) / ==**M(More fragmentation)**== : 다른 패킷의 존재를 알려주는 존재(최대 전송 단위보다 큰 걸 보내면 무조건 1이 된다.))

  - Fragment Offset : 13비트 / 쪼개진 데이터를 원래대로 복구할 때 순서가 보장이 안되기에 순서를 알아볼 수 있게 시작 부분에서 얼마나 떨어져있는지에 대한 정보

- **TTL | Protocol | Header Checksum**

  - TTL(Time To Live) : 패킷이 살아있을 수 있는 시간을 지정(ex. 잘못된 경로 설정으로 순환이 생길 수 있음 ---> 이런 경우를 대비해 패킷이 살아있는 시간(거친 네트워크의 수)을 지정)
    - cf. 운영체제마다 설정하는 값이 다르기에 이를 통해 운영체제를 확인할 수 있음(윈도우는 128 / 리눅스는 64)
  - Protocol : 상위 프로토콜이 뭔지 알려주는 것(ICMP(1) -- 3계층 / TCP(6), UDP(17) -- 4계층)
  - Header Checksum : 헤더가 오류가 있는지 없는지 확인하는 값



## ICMP

### ICMP가 하는 일

### ICMP 프로토콜의 구조



## 라우팅 테이블

### 내가 보낸 패킷은 어디로 가는가

## 다른 네트워크와 통신 과정

### 다른 네트워크까지 내 패킷의 이동 과정



## IPv4의 조각화

### 조각화

### 조각화하는 과정

