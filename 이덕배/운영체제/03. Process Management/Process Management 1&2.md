# Process Management 1&2

[TOC]

#### 프로세스 생성

![프로세스생성](assets\프로세스생성.png)

- 부모 프로세스가 복제 형태를 통해 자식 프로세스 생성
- 부모 프로세스는 여러 명의 자식 프로세스를 생성할 수 있음 => 트리 형태로 발전
- 자원의 공유와 관련해서 보통은 공유 X <= 부모와 자식은 CPU를 서로 얻으려는 경쟁 관계

<hr>

![프로세스생성(2)](assets\프로세스생성(2).png)

- 자식 프로세스는 부모 프로세스의 주소 공간과 운영 체제 데이터(PCB 혹은 자원), CPU 문맥((프로그램 카운터) 등을 똑같이 복제한다(fork() 시스템 콜)
- 리눅스나 효울적인 운영체제에서는 카피 전에 공유할 수 있는 주소 공간과 자원같은 경우는 공유하고 프로그램 카운터만 카피하여 내용이 바뀔 때 복제하는 방식을 사용
- 복제된 곳에 새로운 것을 덮어 씌우는 exec() 시스템 콜
- fork()와 exec()는 독립적인 관계로 각각 실행 가능



#### 프로세스 종료

![프로세스종료](assets\프로세스종료.png)

- exit()은 프로세스의 종료로 자식의 경우 부모한테 데이터를 보냄
- 프로세스에서는 자식이 부모보다 우선적으로 죽어야 함
- 부모가 먼저 종료되는 경우 자손부터 다 죽이고 종료



#### fork() 시스템 콜

![fork](assets\fork.png)

- 위는 C언어 코드
- 원본 구분을 위해  pid를 사용해 부모(양수) / 자식(0)을 사용

<hr>

![fork(2)](assets\fork(2).png)

- 부모가 포크해서 자식이 생기면 자식은 ==메인부터가 아닌 포크 시점부터 실행==(처음부터 X, 문맥 복제)

- 현재 예시와 같은 경우 자식 프로세스에서는 맨 위의 프린트문 실행 X

#### exec()시스템 콜

![exec](assets\exec.png)

- exec() : 새로운 프로세스로 태어나게 해줌

- exec() 시스템 콜 실행 시 , 메인 즉 처음부터 다시 시작

- exec()을 하면 다시 돌아갈 수 없음

- fork()없이 exec()가능 => 부모 프로세스 자체를 새로운 프로세스로 만들어줌(exec()) 이후 코드 실행 불가 (아래 예시의 경우 1 -> hello 3 출력 후 종료)

  cf) echo는 뒤에 나오는 arguments를 그대로 출력해주는 리눅스 커맨드로 

  execip("`프로그램 이름` ", "`프로그램 이름`",  arguments, (char*) 0 ) 구조

  ![exec(2)](assets\exec(2).png)



#### wait() 시스템 콜

![wait](assets\wait.png)

- wait() : 시스템을 잠들게 하는 것(block 상태)
- 자식 프로세스의 종료를 기다리며 block 상태가 된다. -> 자식 프로세스 종료 후에는 ready 상태

- ex) 리눅스 명령어 (셸)프롬포트(실행 후 완료될때까지 기다려야 함)

  

#### exit() 시스템 콜

![exit](assets\exit.png)

- exit() 시스템 콜은 종료 시스템 콜
- 자발적 종료에 주로 호출
- 비자발적 종료 예시 확인



#### 프로세스 관련 시스템 콜 정리

![프로세스시스템콜](assets\시스템콜.png)

- fork() : 복제 생성
- exec() : 새로운 프로그램으로 덮어씌움
- wait() : 자식 프로세스가 끝날 때까지 기다림
- exit() : 프로그램 종료 및 부모 프로세스에게 소식 전달