# 🤔Virtual Memory



## 🧐 가상 메모리



### 🎈 Demand Paging

> 페이지가 요청이 되었을 때 그때 그것을 메모리에 올린다.

##### ✨ 실제로 필요할 때 page를 메모리에 올리는 것

- I/O양의 감소
- Memory 사용량 감소
  (이상한 사람들이 입력값을 넣었을 때를 대비한 가끔 쓰이는 코드를 모두 메모리에 올리는 경우 메모리가 낭비가 될 수 있다. 이때, 필요한 것들만 메모리에 올려 메모리를 효율적으로 사용한다.)
- 빠른 응답 시간
- 더 많은 사용자 수용

##### ✨ Valid / Invalid bit의 사용

- invalid의 의미

  - 사용되지 않는 주소 영역인 경우
  - 페이지가 물리적 메모리에 없는 경우

- 처음에는 모든 page entry가 invalid로 초기화

- address translation 시에 invalid bit이 set되어 있으면 => `page fault`
  (CPU가 논리주소를 보고 주소변환하려고 봤더니 invalid 즉, 요청한 주소가 물리적 메모리에 없는 경우 page fault가 발생
  그러면 CPU는 자동적으로 운영체제(OS)로 넘어가게 된다. 운영체제가 CPU를 가지고 fault난 페이지를 메모리에 올리게 된다.)

- ![](./image/87.png)

  > 필요한 것들만 우선적으로 물리적 메모리에 올려놓고 나머지는 storage(swap 영역)에 올려 놓는다.
  >
  > A,C,F는 실제로 물리적 메모리에 올려져있기 때문에 bit가 v이고 나머지는 i인 것이다.
  >
  > 그리고 현재 프로그램을 구성하는 페이지는 A~F까지이고 G,H는 사용이 안된다
  >
  > 이때, 사용안되는 페이지에 대해서는 invalid로 bit를 준다.



#### 📕 Page Fault

##### ✨ invalid page를 접근하면 MMU가 trap을 발생시킨다.(page fault trap)

##### ✨ Kernel mode로 들어가서 page fault handler가 invoke된다.

##### ✨ 다음의 순서로 page fault를 처리한다.

1. Invalid reference? (eg. bad address, protection violation) => abort process
2. Get an empty page frame (없으면 뺏어온다: replace)
3. 해당 페이지를 disk에서 memory로 읽어온다.
   - disk I/O가 끝나기까지 이 프로세스는 CPU를 preempt 당함(block)
   - Disk read가 끝나면 page tables entry 기록, valid/invalid bit = "valid"
   - ready queue에 process를 insert => dispatch later
4. 이 프로세스가 CPU를 잡고 다시 running
5. 아까 중단되었던 instruction을 재개한다.

![](./image/88.png)

> 1: 페이지 테이블에서 주소변환을 하려고 했는데 invalid임을 확인
> 2: 해당 페이지가 메모리에 없다는 소리이니까 trap이 걸려서 cpu가 os로 넘어가게 된다.
> 3: 운영체제는 backing storage에 있는 페이지를 찾는다.
> 4: 페이지를 메모리에 올린다.
> 5: 올려진 메모리의 번호를 페이지 테이블 entry에 적고 invalid를 valid 상태로 바꾼다.
> 6: 다시 instruction 실행
>
> **🤨 Free frame이 없는 경우**
>
> - Pace replacement(os가 하는 일)
>
>   - 어떤 frame을 빼앗아올지 결정해야 함
>   - 곧바로 사용되지 않을 page를 쫓아내는 것이 좋음
>   - 동일한 페이지가 여러 번 메모리에서 쫓겨났다가 다시 들어올 수 있음
>
> - Replacement Algorithm
>
>   - page-fault rate를 최소화하는 것이 목표
>   - 알고리즘 평가: 푸어진 page reference string에 대해 page fault를 얼마나 내는지 조사
>   - reference string의 예 : 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
>
>   ![](./image/89.png)
>
>   > 1: victim(쫓아낼 페이지)을 backing storage로 쫓아낸다.
>   > 2: 쫓아낸 페이지의 테이블을 invalid로 바꾼다.
>   > 3: 가지고 오려던 페이지를 메모리에 올린다.
>   > 4: 가지고 온 페이지의 테이블을 valid로 바꿔준다.
>
> - Optimal Algorithm
>
>   - page fault를 가장 적게 하는 알고리즘
>   - MIN(OPT): 가장 먼 미래에 참조되는 page를 replace
>   - 해당 알고리즘은 미래를 알고있다는 것을 가정하기 때문에 실제 상황에서 사용하기에는 불가능
>   - 다만 다른 알고리즘의 성능에 대한 upper bound를 제공한다. (비교 지표로 사용)
>   - 미래를 모르면?
>     과거를 참고해서 알고리즘을 짠다 => FIFO, LRU ...
>
> - FIFO(First In First Out) Algorithm
>
>   - 먼저 들어온 것을 먼저 내쫓음
>   - 이 알고리즘은 page frames을 늘려줬는데도 성능이 더 나빠지는 경우가 발생할 수 있다.(FIFO Anomaly)
>
> - LRU(Least Recently Used) Algorithm
>
>   - 가장 많이 사용되는 알고리즘
>   - 가장 오래 전에 참조된 것을 지움
>   - O(1) complexity
>
> - LFU(Least Frequently Used) Algorithm
>
>   - 참조 횟수가 가장 적은 페이지를 지움
>   - O(n) complexity (최소 heap을 사용할 경우 O(log n) complexity)
>   - 최저 참조횟수인 page가 여럿 있는 경우
>     - LFU 알고리즘 자체에서는 여러 page중 임의로 선정한다.
>     - 성능 향상을 위해 가장 오래 전에 참조된 page를 지우게 구현할 수도 있다.
>   - 장단점
>     - LRU처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간 규모를 보기 때문에 page의 인기도를 좀 더 정확히 반영할 수 있다.
>     - 다만, 참조 시점의 최근성을 반영하지 못한다.
>     - 추가적으로 LRU보다 구현이 복잡하다.