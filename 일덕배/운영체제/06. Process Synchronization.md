# 🤔 Process Synchronization



### 📕 데이터의 접근

![](./image/37.png)

Data를 담고있는 Storage 상자를 하나의 Execution 상자가 사용하면

그냥 데이터를 읽고 연산하고 연산 결과를 저장하면 된다.

하지만, 

![](./image/38.png)

이렇게 S-box를 공유하는 E-box가 여럿 있는 경우 Race Condition의 가능성이 생긴다.

(예를 들어, S-box에 1이 저장되어있고 실행하게 되면 E-box들은 1이라는 데이터를 가져간다.
그리고 count++는 1에 더하기를 해서 2를 저장하게되는데,
count--는 1에서 뺄샘을 하여 0을 저장하게 된다.
원래는 1더해지고 1빼지고하여 기존 데이터와 동일한 1이 저장되어야하는데,,
이런 점에서 Race Condition이라는 문제점이 생기게 되는 것이다.)

*Race Condition : 여러 주체가 하나의 데이터를 동시에 접근하려고 할 때, "경쟁상태"

##### ✨ os에서 race condition은 언제 발생하는가?

- kernel 수행 중 인터럽트 발생 시

  ![](./image/39.png)

  > 인터럽트가 발생하게 되는데
  > 결과적으로는 1증가한 값을 저장해놓았다가 count--를 실행하고 증가시켜둔 저장된 값을 Store에 반영한다. 즉, Count--는 반영이 안되는 것이다.
  >
  > 이를 해결하기 위해 중요 변수에 접근할 때는 interrupt가 disable되어 끼어들지 못하게 해두고 작업이 끝나면 interrupt가 실행되게 하는 방법이 있다.
  >
  > 커널모드 running중 interrupt가 발생하여 인터럽트 처리루틴이 수행 
  > => 양쪽 다 커널 코드이므로 kernel address space 공유

- Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우

![](./image/40.png)

> u: user, k: kernel
>
> 시스템콜로 인해서 kernel함수를 실행중이던 와중에 context switch가 발생!
>
> 이렇게 되면 A에서 먼저 count값을 불러왔고 실행중이었기 때문에 B의 덧셈이 반영이 되지 않는다.
>
> 결국 A로 할당이 다시 되어 읽어왔던 값을 1증가시킨 다음에 저장하기 때문이다.
>
> 이를 해결하기 위해 커널 모드에서 수행 중일 때는 CPU를 preempt하지 않는다. 즉 뺏지 않는다는 것이다.
> 커널 모드에서 사용자 모드로 돌아갈 때 preempt!
> (이렇게 되면 할당에 있어서 시간 편차가 조금 생기게 된다. A가 조금 더 할당을 많이 받게 된다. 하지만, 시간을 좀 더 줬다 해서 큰 문제가 발생하진 않는다.)

- Multiprocessor에서 shared memory 내의 kernel data

![](./image/41.png)

> 어떤 CPU가 마지막으로 count를 store했는가? => race condition
>
> multiprocessor의 경우 interrupt enable/disable로 해결되지 않는다.
>
> 방법1. 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법
>
> 방법2. 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 하는 방법
> (맨 처음 데이터에 접근하여 수정할 때 데이터 자체에 다른 cpu가 접근 못하게 lock을 거는 방법, 그리고 수정 후엔 unlock)



## 🧐 Processor Synchronization



### 📗 Process Synchronization 문제

##### ✨ 공유 데이터(shared data)의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있다.

##### ✨ 일관성 유지를 위해서는 협력 프로세스간의 실행순서를 정해주는 메커니즘이 필요하다.

##### ✨ Race condition

- 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
- 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라진다.

##### ✨race condition을 막기 위해서는 동시접근(concurrent process)은 동기화(synchronize)되어야 한다.





### 📕 The Critical-Section Problem

> Critical-Section(임계구역) : 공유데이터에 접근하는 코드
>
> n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우 각 프로세서의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재한다.

문제점은,

하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.

![](./image/42.png)

> 각 공유 데이터에 접근하는 코드인 X=X+1과 X=X-1이 Critical section이 된다.
>
> 그래서 한 프로세스가 공유데이터에 접근하는 Critical section에 들어가면 즉, 공유하는 데이터에 접근하는 코드를 실행중미녀,
> CPU를 뺏겨서 다른 프로세스에 넘어가더라도 공유하는 데이터에 접근하는 critical section에 들어가지 못하게 한다.
>
> critical section에서 빠져 나왔을 때 다른 것에서 접근할 수 있게 된다.
>
> 예를들어 P1에서 접근중일때 CPU가 P2로 넘어가게 되면 이미 critical section을 사용중이기 때문에 코드를 실행하지 못한다.



#### 🎈 프로그램적 해결법의 충족 조건

##### ✨ Mutual Exclusion(상호 배제)

- 프로세스 Pi가 critical section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다

##### ✨ Progress(진행)

- 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다.

##### ✨ Bounded Waiting(유한 대기)

- 프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때 까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.

- critical section에 들어가려는 프로세스가 3개가 있을 때 2개만 번갈아가면서 사용하고 한명은 왕따가 되는 상황을 해결하기 위함이다.



결국 위 총족조건들을 충족시켜야하는데,

![](./image/43.png)

이런 함수를 보았을 때, 

entry section에서 들어갈 때 lock을 걸고, exit section에서 나올 때 lock을 풀어주면 되는 것이다.

이와 관련된 알고리즘을 한번 살펴보자



#### 🎈 critical-section 관련 알고리즘



##### ✨ Algorithm1

![](./image/44.png)

turn은 차례를 나타낸다. 0일때는 P0 프로세스가, 1일때는 P1 프로세스가 critical section에 들어간다.

위 코드에선 critical-section에서 작업을 끝내고 나오면서 turn을 1로 바꿔줌으로써 P1 프로세스가 다음 차례로 critical-section에 들어갈 수 있게 된다.

마찬가지로 P1 프로세스는 critical-section에서 작업을 마치고 다시 turn을 0으로 바꿔준다.

**위 알고리즘은 Mutual Exclusion을 만족하지만 Progress는 만족시키지 못한다.**

아무도 critical section에 있지 않은 상태에서 들어갈 수가 없다.

예를 들어서 P0이 연속적으로 critical section에 들어가려고 하지만 critical section이 **비어있더라고** turn 값이 1이기 때문에 들어갈 수가 없다. 즉, 꼭 P1이 들어가서 turn값을 바꿔줘야지만 P0이 다음으로 들어갈 수 있게 되는 것이다.



##### ✨ Algorithm2

![](./image/45.png)

flag 변수를 활용한다.

flag는 어떤 특정한 프로세스가 critical section을 사용함을 뜻한다.

Pi프로세스가 들어갈 때 본인의 flag값을 true값으로 바꾸고

들어가기전에 다른 상대방이 아직 critical section에 있는지 체크를 하고 있다면 기다린다. 
(while문에 flag[j]값이 true면 j라는 상대방이 아직 critical section에 있는 것이다.)

그리고 본인(i) 차례가 되면 들어가서 작업을 하고 나올 때 본인의 값을 false로 초기화 시키고 나온다.

**위 알고리즘도 Mutual Exclusion을 만족하지만 Progress는 만족시키지 못한다.**

프로세스 i가 flag[i] = true 코드를 통해 깃발을 들고 나서 갑자기 cpu를 뺏겼다.

cpu를 뺏은 프로세스 k가 flag[k] = true 코드를 통해 깃발을 들고 이젠 i, k가 같이 j가 끝나길 기다린다.

k가 이제 critical section에 들어가려고 보니 while문에서 i 이녀석이 깃발을 들고 있다고 나오는 것이다.

i는 들어가기 전에 cpu를 뺏겨서 들어가지 못했는데 말이다.

결국 k, i는 서로 눈치만 보다가 빈 critical section에 들어가지 못한다는 문제점이 생긴다.

둘 다 2행까지만 수행 후 끊임 없이 양보하는 상황이 발생하게 되는 것이다.



##### ✨ Algorithm3 (Peterson's Algorithm)

![](./image/46.png)

위 2 방법을 합친 방법이다.

while문을 보았을 때, 상대방의 flag가 true이고 현재 turn이 상대방이라면 프로세스 i는 기다리게된다.

하지만 둘중 하나라도 충족하지 않는다면 프로세스 i는 critical section에 들어간다. 작업한 뒤 나올 때 flag를 다시 false로 바꿔주고 다른 상대방이 들어갈 수 있게 해준다.
(i가 들어갈때 turn을 j(상대방)으로 바꿔주는데 바꿔줘도 상대방의 flag가 false이면 i는 들어가게된다.)

작업 중 cpu를 빼앗긴다 하더라도 Mutual Exclusion, Progess, Bounded Waiting 삼박자를 모두 만족시킨다.

하지만 Busy Waiting(=spin lock)이라는 문제점이 생긴다. (계속 CPU와 memory를 쓰면서 wait)

ㄴ while문을 계속 돌면서 상대방이 못들어가게 계속 lock을 하게된다. => 자원의 낭비가 발생! 비효율적!



위 알고리즘 3개는 결국 비슷한 맥락이다. 들어가기전에 lock을 걸고 나올 때 unlock을 하는 건데, 

코드가 길어진 이유는 interrupt가 발생할 수 있기 때문이다. 즉, 코드를 수행할때 interrupt가 끼어들어 다 수행하지 못하고 cpu를 뺏기는 것이 문제인 것이다.

이 문제는 sw적인 측면이 아니라 hw적으로 쉽게 고칠 수도 있다.



##### ✨ Synchronization Hardware

하드웨어적으로 Test & modify를 atomic하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결된다.

![](./image/47.png)

들어갈 때, 나올 때 Test_and_Set 함수를 실행하여 lock변수를 true, false 조절을 한다.

들어갈땐 lock을 1로, 나올때는 0으로 해서

만일 누가 들어갈 때 lock이 1인 경우 while문에 걸려서 기다리게된다.



##### ✨ Semaphores (추상 자료형)

사실 프로그래머가 앞의 작업을 하나하나 한다는 것은 굉장히 번거로운 일이다. Semaphores는 위 작업들을 추상화시킨다.

- Semaphore **`S`**

  - S는 정수값을 가질 수 있다. (정수값은 자원의 개수라고 생각하면 된다.)

  - 프로세스가 실행될 때 마다(P함수) 자원(S)를 가져가게 된다.

  - 아래 두가지 atomic 연산에 의해서만 접근 가능하다.

  - ![](./image/48.png)

  - > P연산은 공유 데이터를 획득하는 과정 (lock을 거는 과정)
    >
    > => S값이 0보다 작은 경우 즉, 자원이 없는 경우 while문에 걸려 계속 기다린다.
    >      그러다가 누가 자원을 내놓으면 S값에 -1을 하고 자원을 가져간다.
    >
    > (=> 여기서도 busy-wait문제가 생긴다. 자원이 없는 경우 while문을 계속 돌면서 자원을 낭비시킨다.)
    >
    > V연산은 반납하는 과정 (unlock하는 과정)
    >
    > => 자원을 다 사용한 뒤 S값을 1 증가시킨다.



![](./image/49.png)

Semaphore를 적용시키면 위와 같은데 critical section 전후로 P와 V연산을 해준다.



##### ✨ Block / Wakeup 방식

busy-wait 문제를 해결하는 방법이다.

while문을 도는 것이 아니라 누군가 공유 데이터를 사용중이라면 다른 프로세스 자체를 block시켰다가 공유데이터를 갖고 있던 프로세스가 내놓으면 그때 block을 푸는 방식이다.

- Semaphore를 아래와 같이 정의한다

- ![](./image/50.png)

- > L이라는 하나의 구조적인 wait queue를 만든다.

- block과 wakeup을 아래와 같이 가정한다.

  - block : 커널은 block을 호출한 프로세스를 suspend시킨다. 이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣는다.

    - ![](./image/52.png)

    - > Semaphore의 값 S에 1을 빼주고 S값이 음수이면 자원의 여분이 없다는 이야기이니까 이때는 이 프로세스를 S.L에 연결시켜놓고 block을 시킨다.

  - wakeup(P) : block된 프로세스 P를 wakeup 시킨다. 이 프로세스의 PCB를 ready queue로 옮긴다.

    - ![](./image/53.png)

    - > 자원을 다 쓰고면 S값을 1 증가시켜서 자원을 반납했는데도 S값이 0보다 작으면 누군가 block된 상태가 있다는 뜻이 된다.(위에서 여럿이 (-)를 했다는 뜻이다.)
      > 그래서 잠들어있는 프로세스 하나를 S.L에서 빼서 wakeup 시켜준다.

  - ![](./image/51.png)

  - >  PCB를 계속 매달아 놓는 방식!! 잠들어있는 프로세스들을 연결시켜 놓는 것이다.



##### ✨ Which is better?

- Busy-wait v.s. Block/wakeup
- 보통은 Block/wakeup이 더 효율적일 것이다. while문에서의 자원의 낭비가 없기 때문이다
- 하지만 Block/wakeup도 block을 깨우는 과정에서 overhead가 충분히 존재할 수 있다.
- 그렇기 때문에 Critical section 길이가 그렇게 길지 않다면 Busy-wait한 방법도 나을 수 있다는 것!
  - Critical section의 길이가 긴 경우 Block/wakeup이 적당
  - Critical section 길이가 매우 짧은 경우 Block/wakeup 오버헤드가 busy-wait 오버헤드보다 커질 수 있음



#### 🎈 Deadlock and Starvation

> Semaphore에는 또 다른 문제점이 존재한다.



##### ✨ Deadlock

- 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상
- ![](./image/54.png)
  - P0에서 P(S)를 실행한다.
  - CPU를 P1에 빼앗기게 된다.
  - P1이 P(Q)를 실행하고 P(S)를 실행하려고 보니
  - S는 이미 P0에서 가져갔기 때문에 무한하게 기다려야 된다.
  - V까지 가야 누구든 반환을 하게 되는데 그러한 일은 오지 않는다... 영원히...
- **자원을 얻는 순서를 똑같이 맞춰주면 해결이 된다.**
  (즉, P0과 P1 모두 S, Q 순서로!!)



##### ✨ Starvation

- indefinite blocking
- 프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상
- (특정 프로세스들만 자원을 공유하고 다른 프로세스는 영원히 자기 차례가 오지않는 현상)

