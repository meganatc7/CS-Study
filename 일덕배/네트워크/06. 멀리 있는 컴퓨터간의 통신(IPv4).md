# 🤔 멀리 있는 컴퓨터간의 통신

> 3게층의 역할은 멀리 있는 곳 까지 최적의 경로로 찾아가는 것이다.
> (신뢰성은 4계층에서 보장한다.)



## 🧐 IPv4 프로토콜

> 네트워크 상에서 데이터를 교환하기 위한 프로토콜



#### ▪ 특징

- 네트워크에서 데이터를 교환하기 위한 프로토콜

- 데이터가 정확하게 전달되는 것을 보장하지 않는다.
- 중복된 패킷을 전달하거나 패킷의 순서를 잘못 전달할 가능성도 있다.
- 데이터의 정확하고 순차적인 전달은 그보다 사우이 프로토콜인 TCP(4계층)에서 보장한다.

(단지 3계층에서는 최적 경로로 전달만 하고 신뢰성은 4계층에서 체크!)



#### ▪ 구조

기본적으로 20byte이며 마지막에 옵션(IP Option)으로 4byte 단위로 붙는다.

![image](https://user-images.githubusercontent.com/70757883/127159727-7e4aebce-b0a3-4343-8412-c2ddb38f8c54.png)

**✨Source Address, Destination Address**: 목적지, 출발지 IP주소

**✨ Version**: IP프로토콜의 버전 (4)

**✨IHL(Header Length)**: 보통 길이가 20~60인데 4비트로 표현을 못하니 4로 나는 값을 사용한다.
(일반적으로 앞에는 Version은 4, IHL은 5 이렇게 온다고 보면 된다.)

**✨TOS**: 현재는 사용하지 않는다.(0으로 비워둠)

**✨Total Length**: 뒤의 payload까지의 길이(IHL을 넘어서 전체의 길이)

**✨Identification, Flags, Fragment Offset**: 데이터가 클 때 잘게 족가화 할 때 쓰이는 값들이다.

- `Identification`: 잘개 쪼개진 데이터가 하나의 큰 데이터에서 파생됨을 알리는 식별자(id)값
- `Flag`: 3비트로 'x D M' 이렇게 이렇게 이루어져 있는데 x는 안쓰이는 값, D는 패킷을 보내는 사람이 데이터를 안쪽에서 보내겠다고 명시하는 값(거의 사용x), **M만 주로 Flag에서 쓰이는데 More Fragmentation으로 잘개 쪼개서 보낼 때 첫 패킷 뒤에 다른 패킷들이 더 있다는 것을 알리는 것**

- `Fragment Offset`: 13비트로 쪼개진 데이터를 원래대로 복구할 때 순서를 알아볼 수 있게 Offset 값을 지정하는 것이다. 보통 보낼 때는 순서대로 쪼개서 보내지만 받는 입장에선 처리량이 많아 순서대로 못 받을 수가 있다. 그래서 Offset은 1번 쪼개진 애는 맨 앞에서 0만큼 떨어져있으니 Offset이 0, 2번째 애는 첫번째 애의 크기만큼 떨어져있으니 그만큼의 Offset, 3번째는 1, 2 합친 만큼의 거리...... 이런 흐름으로 Offset값이 결정된다.
  (받는 쪽에선 Offset값과 Id값을 보고 하나의 원래 큰 데이터를 만든다.)

**✨TTL**: Time to live로 패킷이 살아 있을 수 있는 시간을 지정하는 부분이다. 특정 숫자값을 입력하여 보내는데 3계층 장비인 라우터를 거칠 때 마다 1씩 줄어든다. 무한으로 도는 것을 막기 위함이며, 이걸 응용하여 흥미롭게도 상대방의 OS가 무엇인지 알 수가 있다.(window는 ttl이 128, Linux는 68)

**✨Protocol**: 이더넷의 타입과 같이 상위 프로토콜이 뭔지 알려주는 부분이다. IP 프로토콜 입장에서 상위 프로토콜로 올수 있는 것들은 (ICMP: 01, TCP: 06, UDP: 17) 이며 이 중 무엇인지 알려준다.

**✨Header Checksum**: 해당 헤더에 오류가 있는지 없는지 확인하는 값이다. 헤더의 필드에 있는 값들로 계산을 하고 보내고 받는 측에서는 다시 계산하여 일치하는지 확인한다.





## 🧐 ICMP 프로토콜

> 인터넷 제어 메시지 프로토콜



#### ▪ 특징

- Internet Control Message Protocol: 인터넷 제어 메시지 프로토콜
- 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송 받는데 주로 사용한다.
- 프로토콜 구조의 Type과 Code를 통해 오류 메시지를 전송 받는다.
- 상대방과 통신이 되나 안되나 확인하기 위한 프로토콜



#### ▪ 구조

![image](https://user-images.githubusercontent.com/70757883/127161413-7370c386-9aa5-40b4-a9c0-208a2a7f482f.png)

**✨ Type**: 카테고리(대분류)

- 8번: 요청
- 0번: 응답
- 3번: 목적지에 도달 불가능
- 11번: 요청시간 만료

**✨Code**: 나머지 소분류



## 🧐 라우팅 테이블

> 3계층의 역할은 최적 경로를 찾는 것!
>
> 그 최적 경로를 지도처럼 저장해 놓은 것이 라우팅 테이블이다.
>
> 해당 테이블에 적힌 위치에만 찾아 갈 수 있다.



#### ▪ 다른 네트워크와 통신하는 과정



##### 1.  A에서 통신 시작

![image](https://user-images.githubusercontent.com/70757883/127163888-a711af59-4f87-4209-af43-478efbeaf8ca.png)



##### 2. B의 네트워크 대역인 192.168.20.0/24가 A의 라우팅 테이블에 있어야지만 통신이 가능하다. 현재 테이블에서는 B의 네트워크 대역으로 가기 위해선 192.168.10.1로 가도록 표시해주고 있다.

![image](https://user-images.githubusercontent.com/70757883/127164083-84e4d1cd-9b28-4ac4-bd98-596fbc55e2e8.png)



##### 3. 테이블에 표시된 대로 Eth(이더넷 프로토콜)의 목적지 MAC주소는 cc:cc:cc:cc:cc:cc가 된다. (만일 모른다면 ARP로 알아와야겠지?)

![image](https://user-images.githubusercontent.com/70757883/127164534-010b07c4-412f-445f-a6fd-b30ae64f27b0.png)



##### 4. 이제 패킷을 보내는데, 가운데 스위치로 보내져서 2계층까지 확인(이더넷까지만 확인)해보고 c에게 보내는 것을 확인한 뒤 c에게 보낸다.

![image](https://user-images.githubusercontent.com/70757883/127164703-e86d3ac5-71e3-4da1-a901-3cd7cb04c890.png)



##### 5. 다음으로 넘어가서 2계층을 확인해보고 목적지 주소가 c, 즉 자기 자신임을 확인한다.

![image](https://user-images.githubusercontent.com/70757883/127164825-57b97b1a-8075-46c0-8b08-e7d39d5be390.png)



##### 6. 그리고 3계층을 디캡슐레이션해보는데, 이때 목적지 IP주소(c0 a8 14 14)가 자기가 아님을 확인하고 자신의 라우팅 테이블을 확인해본다.

![image](https://user-images.githubusercontent.com/70757883/127165017-13c1e245-c59c-4fa4-b160-a425ba013952.png)



##### 7. 확인해봤더니, 20번대 대역은 옆에 있는 라우터에게 가라고 테이블에 적혀있다.(192.168.30.2)

![image](https://user-images.githubusercontent.com/70757883/127165219-5796f5d0-c299-48ec-b541-27cc1accbb0f.png)



##### 8. 그리고 보내기 전에 이더넷 프로토콜을 수정한다. 목적지 MAC과 출발지 MAC주소를 자기 옆에 있는 네트워크 대역에서 통신할 수 있는 것으로 바꿔준다.(이 경우 녹색 네트워크 대역에서 사용가능하도록 MAC주소를 짜주는 것이다.)

![image](https://user-images.githubusercontent.com/70757883/127165403-2b82e2d4-3b85-40c8-986a-c3d6452801d5.png)



##### 9. 다음으로 보내고 마찬가지로 2계층에 이어 3계층 까지 디캡슐레이션 해본 뒤 목적지 주소를 확인한다.

![image](https://user-images.githubusercontent.com/70757883/127165513-e209fbb5-d317-4c9b-9906-dfebcc8e6161.png)



##### 10. 똑같은 메커니즘으로 라우팅 테이블을 확인한다. 20번대 대역은 40번대로 보내도록 되어있다.(보라색 영역)

![image](https://user-images.githubusercontent.com/70757883/127165691-6e0325b3-42a6-4d28-b9bf-bbadd46d0548.png)



##### 11. 그리곤 똑같이 이더넷 프로토콜을 다시 수정한다.

![image](https://user-images.githubusercontent.com/70757883/127165828-93973847-2923-4b0d-b17a-ed35b65cce55.png)



##### 12. 마찬가지의 과정을 거쳐서 가고 3계층 까지 디캡슐레이션을 하여 주소 확인하고 / 라우팅 테이블 확인하고 / 이더넷 프로토콜 확인하고 / 이제 여기서 목적지 주소가 b로 된다.

![image](https://user-images.githubusercontent.com/70757883/127166005-0f5843b4-9483-42c5-af8f-b970dd12878f.png)



이후 과정은 스위치로 가서 2계층(이더넷 프로토콜)까지 디캡슐레이션 하고 목적지인 b로 전송을 해주면 통신이 되는 것이다.

B는 ICMP 요청을 받았으니 역순으로 ICMP 응답을 이제 보내준다.





## 🧐 IPv4의 조각화

> 크기가 큰 데이터를 전송할 때 최대 전송 단위(MTU)를 맞추기 위해 여러 패킷으로 쪼개서 전송하게 되는데, 이를 패킷의 `조각화`라고 한다.



#### ▪ 특징

- 프로토콜을 인캡슐레이션하여 데이터를 보낼 때 데이터의 최대 전송 단위인 MTU가 보통장비마다 설정되어 있으며 보통 1500bytes로 되어있다.
- 만약 보내려는 payload가 1500bytes보다 크다면, IPv4 프로토콜에서 조각화 작업을 하여 데이터를 전송하게 된다.
- 큰 IP 패킷들이 작은 MTU(Maximum Transmission Unit)를 갖는 링크를 통하여전송되려면 여러 개의 작은 패킷으로 조각화되어 전송되어야 한다.

- 목적지까지 패킷을 전달하는 과정에서 통과하는 각 라우터마다 전송에 적합한 프레임으로 변환이 필요하다.(각 라우터마다 MTU가 다를 수 있으니까)
- 일단 조각화되면, 최종 목적지에 도달할 때 까지 재조립되지 않는 것이 일반적이다.
- IPv4에서는 발신지 뿐만 아니라 중간 라우터에서도 IP 조각화가 가능하지만, IPv6에서는 IP 단편화가 발신지에서만 가능하며 재조립은 항상 최종 수신지에서만 가능하다.



#### ▪ 조각화 예시

![image](https://user-images.githubusercontent.com/70757883/127167486-73881f11-e659-4c8a-bbc1-f5c1d57650ec.png)

##### 1.  `11,980bytes + 20bytes(IPv4 프로토콜) = 12,000bytes` 데이터를 보내려고 한다.

##### 2, MTU가 3,300bytes로 설정되어있다고 가정한다면, 내가 보내려는 데이터가 크기 때문에 MTU에 맞춰 데	이터를 조각화 해줘야 한다.

##### 3. 11,980bytes를 쪼갤 때는 MTU가 3300이라고 3300씩 나누는게 아니라 IPv4 프로토콜의 크기만큼 고려	해준 값인 3,280bytes씩 조각화한다. (MTU가 1,000이라면 980씩)

**✨MF**: More Fragment로 내 뒤에 패킷이 더 있다는 신호로 1, 마지막 조각에는 0

**✨ Offset**: 거리 값. 첫 시작은 0, 두번째에는 첫 번째 데이터 크기만큼의 거리로 여기서도 3,280을 그대로 거리 값으로 사용하지 않고 8로 나누서 410을 사용한다.(큰 숫자는 다 표현하지 못할 수 있어서 8로 나눠준다.). 그러면 두번째 Offset은 410, 세번째 Offset은 820 이렇게 된다.

*조각화된 4개의 패킷은 각자 IP프로토콜을 갖고 MF, Offset은 다르지만 **ID값**은 4개 모두 같다. 해당 ID(식별자값)로 어떤 큰 데이터에서 쪼개졌는지를 나타내줌으로써 나중에 최종적으로 합쳐서 11,980bytes 데이터를 찾아내는 흐름이다.



#### ▪ 조각화 과정



##### 1. 2,000(data) + 8(ICMP) + 20(IPv4) = 2,028 크기의 데이터를 보내려고 하는데 MTU는 1500이어서 조각화 가 필요하다.

![image](https://user-images.githubusercontent.com/70757883/127169355-1beb2ed7-061f-4545-8609-3b176f594671.png)



##### 2. 처음에 데이터를 1,480과 520으로 쪼개고 맨 마지막 데이터에만 ICMP를 붙이고 각각에 IPv4 프로토콜을 붙이는 작업을 한다. 이젠 MTU에 안걸리니 이더넷 프로토콜까지 인캡슐레이션을 한다.(조각화 작업을 한 뒤 이더넷을 붙여준다.)

![image](https://user-images.githubusercontent.com/70757883/127169584-f84b96cf-032d-474a-b84a-d2f28d981b2f.png)



##### 3. 각각의 IPv4프로토콜을 확인해 보면,

![image](https://user-images.githubusercontent.com/70757883/127169694-9d8fd81e-4fc5-4151-9093-dd64ab1a8bba.png)

**✨ 4 5 00**: 항상 Version과 IHL(Header Length)로 4 5 값을 가진다.

**✨ 05 dc, 02 24**: 전체 길이로 각각 1,500bytes, 548bytes

**✨ 12 ab**: IPv4 프로토콜의 id값(두 패킷 모두 같다.)

**✨2**: More Fragment가 세팅되어 있는 것이다.(1인데 이진수로 표시할 때 0010이 되어 2가 된다.)

**✨0 00**: Offset값으로 첫 번째 패킷이니 0으로 설정

**✨ 0 b9**: 첫번째 패킷의 크기인 1,480/8 = 185가되어 16진수 표기

**✨80**: TTL(Time to live)값으로 장비 하나 넘어갈때마다 1씩 깎이는 값

**✨01**: 상위 프로토콜의 값(ICMP)

**✨00 00**: check sum 값

**✨c0 a8 0a 0a**: 출발지 ip

**✨c0 a8 14 14**: 도착지 ip